-- 20260203000000_full_schema_sync.sql
-- FULL DATABASE SCHEMA SYNCHRONIZATION
-- Generated by Senior Architect (Auto-Sync Tool)
-- Matches LIVE Supabase Schema as of Feb 03, 2026

-- Enable UUID extension
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

-- ==========================================
-- 1. INDEPENDENT TABLES (Dictionaries/Masters)
-- ==========================================

-- PRODUCTS
CREATE TABLE IF NOT EXISTS products (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT NOT NULL,
    category TEXT NOT NULL,
    size TEXT CHECK (size IN ('Small', 'Medium', 'Large')),
    default_weight NUMERIC NOT NULL CHECK (default_weight > 0),
    wastage_percent NUMERIC NOT NULL DEFAULT 0,
    labour_cost NUMERIC NOT NULL DEFAULT 0,
    current_stock NUMERIC NOT NULL DEFAULT 0 CHECK (current_stock >= 0),
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- JOB WORK ITEMS
CREATE TABLE IF NOT EXISTS job_work_items (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT NOT NULL UNIQUE,
    unit TEXT NOT NULL CHECK (unit IN ('KG', 'Piece', 'Jodi')),
    default_rate NUMERIC NOT NULL CHECK (default_rate >= 0),
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- LEDGERS (Accounting Master)
CREATE TABLE IF NOT EXISTS ledgers (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT NOT NULL,
    type TEXT NOT NULL,
    is_system BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- SETTINGS
CREATE TABLE IF NOT EXISTS settings (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID REFERENCES auth.users NOT NULL,
    category VARCHAR(50) NOT NULL,
    settings JSONB NOT NULL DEFAULT '{}',
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW()
);

-- SILVER RATES
CREATE TABLE IF NOT EXISTS silver_rates (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    rate_date DATE NOT NULL,
    source TEXT NOT NULL,
    rate_10g NUMERIC NOT NULL,
    rate_1g NUMERIC NOT NULL,
    notes TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- KARIGARS
CREATE TABLE IF NOT EXISTS karigars (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT NOT NULL,
    type TEXT NOT NULL,
    status TEXT DEFAULT 'Active',
    phone TEXT,
    current_balance NUMERIC DEFAULT 0,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- ==========================================
-- 2. OPERATIONAL TABLES (Transactions)
-- ==========================================

-- ORDERS
CREATE TABLE IF NOT EXISTS orders (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    order_number SERIAL NOT NULL,
    order_date DATE NOT NULL DEFAULT CURRENT_DATE,
    customer_name TEXT NOT NULL,
    material_type TEXT NOT NULL CHECK (material_type IN ('CLIENT', 'OWN')),
    user_id UUID REFERENCES auth.users NOT NULL,
    gst_enabled BOOLEAN DEFAULT FALSE,
    gst_rate NUMERIC DEFAULT 0,
    gst_amount NUMERIC DEFAULT 0,
    subtotal NUMERIC DEFAULT 0,
    total_amount NUMERIC DEFAULT 0,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- ORDER ITEMS
CREATE TABLE IF NOT EXISTS order_items (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    order_id UUID REFERENCES orders(id) ON DELETE CASCADE NOT NULL,
    description TEXT NOT NULL,
    quantity NUMERIC NOT NULL CHECK (quantity > 0),
    unit TEXT NOT NULL,
    rate NUMERIC NOT NULL CHECK (rate >= 0),
    amount NUMERIC GENERATED ALWAYS AS (quantity * rate) STORED,
    product_id UUID REFERENCES products(id),
    weight NUMERIC,
    wastage_percent NUMERIC,
    labour_cost NUMERIC
);

-- EXPENSES
CREATE TABLE IF NOT EXISTS expenses (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    date DATE NOT NULL,
    head TEXT NOT NULL,
    amount NUMERIC NOT NULL,
    notes TEXT,
    gst_enabled BOOLEAN DEFAULT FALSE,
    gst_rate NUMERIC,
    gst_amount NUMERIC,
    invoice_number TEXT,
    vendor_name TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- TRANSACTIONS (Accounting Journal)
CREATE TABLE IF NOT EXISTS transactions (
    ledger_id UUID REFERENCES ledgers(id) NOT NULL,
    order_id UUID REFERENCES orders(id),
    date DATE NOT NULL,
    debit NUMERIC DEFAULT 0,
    credit NUMERIC DEFAULT 0,
    description TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW()
);
-- Note: 'debit' and 'credit' columns often exist alongside 'type'/'amount' in hybrid schemas or are generated. 
-- Based on live schema inspection, they exist.

-- STOCK TRANSACTIONS
CREATE TABLE IF NOT EXISTS stock_transactions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    date TIMESTAMPTZ NOT NULL,
    type TEXT NOT NULL,
    item_type TEXT NOT NULL,
    product_id UUID REFERENCES products(id),
    order_id UUID REFERENCES orders(id),
    quantity NUMERIC NOT NULL,
    weight_gm NUMERIC,
    note TEXT,
    user_id UUID REFERENCES auth.users,
    source TEXT,
    rate_at_time NUMERIC,
    wastage_percent NUMERIC,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- KARIGAR WORK RECORDS
CREATE TABLE IF NOT EXISTS karigar_work_records (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    karigar_id UUID REFERENCES karigars(id) NOT NULL,
    order_id UUID REFERENCES orders(id),
    description TEXT,
    quantity NUMERIC NOT NULL,
    rate NUMERIC NOT NULL,
    amount NUMERIC NOT NULL,
    payment_status TEXT,
    payment_date DATE,
    payment_mode TEXT,
    work_date DATE NOT NULL,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- ==========================================
-- 3. INDEXES & CONSTRAINTS
-- ==========================================

CREATE UNIQUE INDEX IF NOT EXISTS idx_settings_user_category ON settings(user_id, category);
CREATE INDEX IF NOT EXISTS idx_settings_user_id ON settings(user_id);
CREATE INDEX IF NOT EXISTS idx_orders_user_id ON orders(user_id);
CREATE INDEX IF NOT EXISTS idx_stock_product_id ON stock_transactions(product_id);
CREATE INDEX IF NOT EXISTS idx_transactions_ledger_id ON transactions(ledger_id);

-- ==========================================
-- 4. ROW LEVEL SECURITY (RLS) POLICIES
-- ==========================================

-- Enable RLS
ALTER TABLE orders ENABLE ROW LEVEL SECURITY;
ALTER TABLE order_items ENABLE ROW LEVEL SECURITY;
ALTER TABLE products ENABLE ROW LEVEL SECURITY;
ALTER TABLE job_work_items ENABLE ROW LEVEL SECURITY;
ALTER TABLE ledgers ENABLE ROW LEVEL SECURITY;
ALTER TABLE settings ENABLE ROW LEVEL SECURITY;
ALTER TABLE silver_rates ENABLE ROW LEVEL SECURITY;
ALTER TABLE karigars ENABLE ROW LEVEL SECURITY;
ALTER TABLE expenses ENABLE ROW LEVEL SECURITY;
ALTER TABLE transactions ENABLE ROW LEVEL SECURITY;
ALTER TABLE stock_transactions ENABLE ROW LEVEL SECURITY;
ALTER TABLE karigar_work_records ENABLE ROW LEVEL SECURITY;

-- Policies (Standard: Users see their own data, or authenticated sees all for masters)

-- Orders: Strict ownership
CREATE POLICY "Users can view their own orders" ON orders FOR SELECT USING (auth.uid() = user_id);
CREATE POLICY "Users can insert their own orders" ON orders FOR INSERT WITH CHECK (auth.uid() = user_id);
CREATE POLICY "Users can update their own orders" ON orders FOR UPDATE USING (auth.uid() = user_id);
CREATE POLICY "Users can delete their own orders" ON orders FOR DELETE USING (auth.uid() = user_id);

-- Order Items: Link to orders
CREATE POLICY "Users access order items via order" ON order_items FOR ALL USING (
  EXISTS (SELECT 1 FROM orders WHERE orders.id = order_items.order_id AND orders.user_id = auth.uid())
);

-- Products: Authenticated view, Admin manage (Simplified: Auth users full access)
CREATE POLICY "Auth users full access products" ON products FOR ALL USING (auth.role() = 'authenticated');

-- Job Work Items
CREATE POLICY "Auth users full access job_work" ON job_work_items FOR ALL USING (auth.role() = 'authenticated');

-- Ledgers
CREATE POLICY "Auth users access ledgers" ON ledgers FOR ALL USING (auth.role() = 'authenticated');

-- Settings
CREATE POLICY "Users own settings" ON settings FOR ALL USING (auth.uid() = user_id);

-- Transactions: Strict ownership (if user_id present) or Auth access
CREATE POLICY "Users own transactions" ON transactions FOR ALL USING (auth.uid() = user_id);

-- Expenses
CREATE POLICY "Auth users access expenses" ON expenses FOR ALL USING (auth.role() = 'authenticated');

-- Stock Actions
CREATE POLICY "Users own stock actions" ON stock_transactions FOR ALL USING (auth.uid() = user_id);

-- Others
CREATE POLICY "Auth users access silver_rates" ON silver_rates FOR ALL USING (auth.role() = 'authenticated');
CREATE POLICY "Auth users access karigars" ON karigars FOR ALL USING (auth.role() = 'authenticated');
CREATE POLICY "Auth users access karigar_records" ON karigar_work_records FOR ALL USING (auth.role() = 'authenticated');

-- ==========================================
-- 5. FUNCTIONS & TRIGGERS
-- ==========================================

-- Trigger: Decrement Stock (Legacy/Simple) - REMOVED to prevent double deduction
-- Logic is now handled inside create_order_atomic RPC
-- CREATE OR REPLACE FUNCTION decrement_stock()...

-- settings timestamp updater
CREATE OR REPLACE FUNCTION update_settings_updated_at()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER settings_updated_at BEFORE UPDATE ON settings FOR EACH ROW EXECUTE FUNCTION update_settings_updated_at();

-- ==========================================
-- 6. CRITICAL RPC: CREATE_ORDER_ATOMIC
-- ==========================================

CREATE OR REPLACE FUNCTION create_order_atomic(
    p_customer_name TEXT,
    p_order_date DATE,
    p_material_type TEXT,
    p_items JSONB,
    p_gst_enabled BOOLEAN DEFAULT FALSE
)
RETURNS JSONB
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
    v_order_id UUID;
    v_item RECORD;
    v_user_id UUID;
    v_current_stock NUMERIC;
    v_product_name TEXT;
    
    -- Financial Variabls
    v_subtotal NUMERIC := 0;
    v_gst_rate NUMERIC := 3; -- Default Silver GST
    v_gst_amount NUMERIC := 0;
    v_total_amount NUMERIC := 0;
    
    -- Ledger IDs (You would normally look these up dynamically or pass them in)
    -- For safety, we try to look them up or create them.
    v_customer_ledger_id UUID;
    v_income_ledger_id UUID;
    v_gst_ledger_id UUID;
    v_current_rate NUMERIC;
BEGIN
    v_user_id := auth.uid();
    
    -- 1. Get/Create Ledgers
    -- Customer
    SELECT id INTO v_customer_ledger_id FROM ledgers WHERE name = p_customer_name LIMIT 1;
    IF v_customer_ledger_id IS NULL THEN
        -- Customers are Assets (Accounts Receivable)
        INSERT INTO ledgers (name, type) VALUES (p_customer_name, 'ASSET') RETURNING id INTO v_customer_ledger_id;
    END IF;
    
    -- Income
    SELECT id INTO v_income_ledger_id FROM ledgers WHERE name = (CASE WHEN p_material_type = 'CLIENT' THEN 'Job Work Income' ELSE 'Product Sales Income' END) LIMIT 1;
    IF v_income_ledger_id IS NULL THEN
        INSERT INTO ledgers (name, type) VALUES ((CASE WHEN p_material_type = 'CLIENT' THEN 'Job Work Income' ELSE 'Product Sales Income' END), 'INCOME') RETURNING id INTO v_income_ledger_id;
    END IF;
    
    -- GST
    IF p_gst_enabled THEN
        SELECT id INTO v_gst_ledger_id FROM ledgers WHERE name = 'GST Output Tax' LIMIT 1;
        IF v_gst_ledger_id IS NULL THEN
            INSERT INTO ledgers (name, type) VALUES ('GST Output Tax', 'LIABILITY') RETURNING id INTO v_gst_ledger_id;
        END IF;
    END IF;

    -- 2. Calculate Totals First
    FOR v_item IN SELECT * FROM jsonb_to_recordset(p_items) AS x(
        quantity NUMERIC, 
        rate NUMERIC
    ) LOOP
        v_subtotal := v_subtotal + (v_item.quantity * v_item.rate);
    END LOOP;
    
    IF p_gst_enabled THEN
        v_gst_amount := (v_subtotal * v_gst_rate) / 100;
    END IF;
    
    v_total_amount := v_subtotal + v_gst_amount;

    -- 3. Insert Order
    INSERT INTO orders (
        customer_name, order_date, material_type, user_id, 
        gst_enabled, gst_rate, gst_amount, subtotal, total_amount
    )
    VALUES (
        p_customer_name, p_order_date, p_material_type, v_user_id,
        p_gst_enabled, v_gst_rate, v_gst_amount, v_subtotal, v_total_amount
    )
    RETURNING id INTO v_order_id;
    
    -- Get Current Silver Rate for Stock Valuation
    SELECT rate_1g INTO v_current_rate FROM silver_rates ORDER BY rate_date DESC LIMIT 1;
    IF v_current_rate IS NULL THEN v_current_rate := 0; END IF;

    -- 4. Process Items
    FOR v_item IN SELECT * FROM jsonb_to_recordset(p_items) AS x(
        description TEXT, 
        quantity NUMERIC, 
        unit TEXT, 
        rate NUMERIC, 
        product_id UUID,
        weight NUMERIC,
        wastage_percent NUMERIC,
        labour_cost NUMERIC,
        karigar_id UUID,
        karigar_rate NUMERIC,
        karigar_quantity NUMERIC
    ) LOOP
        -- A) Stock Logic: If OWN material, check and reduce stock
        IF p_material_type = 'OWN' AND v_item.product_id IS NOT NULL THEN
            SELECT current_stock, name INTO v_current_stock, v_product_name 
            FROM products WHERE id = v_item.product_id;
            
            IF v_current_stock < v_item.quantity THEN
                RAISE EXCEPTION 'Insufficient stock for "%". Available: %', v_product_name, v_current_stock;
            END IF;

            -- Actually reduce stock
            UPDATE products 
            SET current_stock = current_stock - v_item.quantity 
            WHERE id = v_item.product_id;
            
            -- Log Stock Transaction
            INSERT INTO stock_transactions (
                date, type, item_type, product_id, quantity, weight_gm, note, user_id, source, rate_at_time, order_id
            ) VALUES (
                p_order_date, 'ORDER_DEDUCTION', 'FINISHED_GOODS', v_item.product_id, v_item.quantity, 
                (v_item.quantity * COALESCE(v_item.weight, 0)), 
                'Order Creation: ' || p_customer_name, v_user_id,
                'Order #' || v_order_id, v_current_rate, v_order_id
            );
        END IF;

        -- B) Insert Order Item
        INSERT INTO order_items (
            order_id, description, quantity, unit, rate, product_id, weight, wastage_percent, labour_cost
        ) VALUES (
            v_order_id, v_item.description, v_item.quantity, v_item.unit, v_item.rate, v_item.product_id, v_item.weight, v_item.wastage_percent, v_item.labour_cost
        );

        -- C) Karigar Work Record (If assigned)
        IF v_item.karigar_id IS NOT NULL THEN
            INSERT INTO karigar_work_records (
                karigar_id, order_id, description, quantity, rate, amount, work_date, payment_status
            ) VALUES (
                v_item.karigar_id, v_order_id, v_item.description || ' (Order Item)',
                COALESCE(v_item.karigar_quantity, v_item.quantity),
                COALESCE(v_item.karigar_rate, 0),
                (COALESCE(v_item.karigar_quantity, v_item.quantity) * COALESCE(v_item.karigar_rate, 0)),
                p_order_date, 'PENDING'
            );
        END IF;
    END LOOP;

    -- 5. Financial Transaction (Accounting Journal Entry)
    
    -- Debit Customer (Receivable)
    INSERT INTO transactions (ledger_id, date, type, amount, debit, credit, description, order_id, user_id)
    VALUES (v_customer_ledger_id, p_order_date, 'DEBIT', v_total_amount, v_total_amount, 0, 'Order #' || v_order_id, v_order_id, v_user_id);
    
    -- Credit Income
    INSERT INTO transactions (ledger_id, date, type, amount, debit, credit, description, order_id, user_id)
    VALUES (v_income_ledger_id, p_order_date, 'CREDIT', v_subtotal, 0, v_subtotal, 'Sales Income from Order #' || v_order_id, v_order_id, v_user_id);
    
    -- Credit GST Liability (if any)
    IF v_gst_amount > 0 THEN
        INSERT INTO transactions (ledger_id, date, type, amount, debit, credit, description, order_id, user_id)
        VALUES (v_gst_ledger_id, p_order_date, 'CREDIT', v_gst_amount, 0, v_gst_amount, 'GST Output for Order #' || v_order_id, v_order_id, v_user_id);
    END IF;

    RETURN jsonb_build_object('order_id', v_order_id, 'total_amount', v_total_amount);
END;
$$;

-- ==========================================
-- 7. SEED DATA (Base Setup)
-- ==========================================
-- (Optional: Only if table is empty, preventing dupes)
INSERT INTO ledgers (name, type, is_system) VALUES 
('GST Output Tax', 'LIABILITY', TRUE),
('Job Work Income', 'INCOME', TRUE),
('Product Sales Income', 'INCOME', TRUE)
ON CONFLICT DO NOTHING; -- Assuming name constraint, but since none defined, we rely on logic or skip in real deploy. 
-- In real migrations, handle with care.

